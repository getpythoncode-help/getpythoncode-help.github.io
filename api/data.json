
[
  {
    "Week-7: Programing Assignment-01": "#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Student {\n    char name[21];   // name (up to 20 chars + '\\0')\n    int physics;\n    int chemistry;\n    int maths;\n};\n\n// comparator for qsort\nint compare(const void *a, const void *b) {\n    struct Student *s1 = (struct Student *)a;\n    struct Student *s2 = (struct Student *)b;\n\n    // Compare Physics\n    if (s1 -> physics != s2->physics) {\n        return (s2 -> physics - s1->physics);  // descending order\n    }\n    // Compare Chemistry\n    if (s1 -> chemistry != s2->chemistry) {\n        return (s2 -> chemistry - s1 -> chemistry);\n    }\n    // Compare Maths\n    return (s2 -> maths - s1 -> maths);  // descending order\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    struct Student arr[100];\n\n    for (int iq = 0; iq < n; iq++) {\n        scanf(\"%s %d %d %d\", arr[iq].name, &arr[iq].physics,\n              &arr[iq].chemistry, &arr[iq].maths);\n    }\n\n    qsort(arr, n, sizeof(struct Student), compare);\n\n    for (int i = 0; i < n; i++) {\n        printf(\"%s %d %d %d\\n\", arr[i].name,\n               arr[i].physics, arr[i].chemistry, arr[i].maths);\n    }\n\n    return 0;\n}\n ",
    "Week-7: Programing Assignment-02": " #include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct node {\n    int id;\n    int value;\n    struct node *next;\n};\n\nstruct node *create_node(int id, int val) {\n    struct node *new_node = (struct node *)malloc(sizeof(struct node));\n    if (new_node == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        exit(1);\n    }\n    new_node -> id = id;\n    new_node -> value = val;\n    new_node -> next = NULL;\n    return new_node;\n}\n\nstruct node *append(struct node *list, struct node *e) {\n    e -> next = list;   // insert at head\n    return e;         // new head is the new node\n}\n\nstruct node *search(struct node *list, int id) {\n    while (list != NULL) {\n        if (list -> id == id)\n            return list;   // found\n        list = list->next;\n    }\n    return NULL;  // not found\n}\n\nvoid change_value(struct node *list, int id, int val) {\n    struct node *e = search(list, id);\n    if (e != NULL) {\n        e -> value = val;   // update value\n    }\n}\n\nint find_value(struct node *list, int id) {\n    struct node *e = search(list, id);\n    if (e != NULL)\n        return e -> value;\n    return -1;\n}\n\nint main() {\n    char op;\n    int id, val;\n    struct node *list = NULL;\n\n    int flagship = 1;\n    do {\n        scanf(\" %c\", &op);\n        switch (op) {\n            case 'A':\n                scanf(\"%d %d\", &id, &val);\n                list = append(list, create_node(id, val));\n                break;\n            case 'S':\n                scanf(\"%d\", &id);\n                printf(\"%d %d\\n\", id, find_value(list, id));\n                break;\n            case 'C':\n                scanf(\"%d %d\", &id, &val);\n                change_value(list, id, val);\n                break;\n            case 'E':\n                flagship = 0;\n                break;\n        }\n    } while (flagship == 1);\n\n    return 0;\n}\n",
    "Week-7: Programing Assignment-03": " Question not given by NPTEL"
  },
  {
    "Week-5 Programing Assignment-01": "#include &lt;stdio.h&gt;\n\nvoid reverse() {\n    int cgp = getchar();  // read one character\n    if (cgp != EOF && cgp != '\\n') {\n        reverse();      // recursive call before printing\n        putchar(cgp);     // print when stack unwinds\n    }\n}\n\nint main() {\n    reverse();   // call recursive function\n    return 0;\n}\n ",
    "Week-5 Programing Assignment-02": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid genBinary(char *s, int i, int N) {\n    if (i == N) {\n        s[N] = '\\0';\n        printf(\"%s\\n\", s);\n        return;\n    }\n\n    // First choice: put '0'\n    s[i] = '0';\n    genBinary(s, i + 1, N);\n\n    // Second choice: put '1'\n    s[i] = '1';\n    genBinary(s, i + 1, N);\n}\n\nint main(void) {\n    char A[8];\n    int ntg;\n    scanf(\"%d\", &ntg);\n\n    genBinary(A, 0, ntg);\n\n    return 0;\n}\n",
    "Week-5 Programing Assignment-03": "#include &lt;stdio.h&gt;\n\n// Recursive function to compute BlockSum\nint blockSum(int *M, int nok) {\n    if (nok == 2) {\n        return M[0] - M[1];  // base case\n    }\n    int mid = nok / 2;\n    int left = blockSum(M, mid);         // first half\n    int right = blockSum(M + mid, mid);  // second half\n    return left - right;                 // recursive step\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int M[1024];  // max size as per problem constraint\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &M[i]);\n    }\n\n    int result = blockSum(M, n);\n    printf(\"%d\", result);\n\n    return 0;\n}\n "
  },
  {
    "Week-6 Programing Assignment-01": " #include &lt;stdio.h&gt;\n\n// Complete this Function to check if a matrix is symmetric.\n// A is an n*n Matrix. Return 1 if A is symmetric and 0 otherwise.\nint isSymmetric(int A[10][10], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int jpg = 0; jpg < n; jpg++) {\n            if (A[i][jpg] != A[jpg][i]) {\n                return 0; // Not symmetric\n            }\n        }\n    }\n    return 1; // Symmetric\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int A[10][10];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    printf(\"%d\", isSymmetric(A, n));\n\n    return 0;\n}\n",
    "Week-6 Programing Assignment-02": " #include &lt;stdio.h&gt;\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int A[100][100];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    int ipl2 = 0, j = 0;\n    // We know there is exactly one path; we follow 1's\n    while (ipl2 != n - 1 || j != n - 1) {\n        // Prefer moving right if possible\n        if (j + 1 < n && A[ipl2][j + 1] == 1) {\n            printf(\"R\");\n            j++;\n        }\n        // Otherwise move down\n        else if (ipl2 + 1 < n && A[ipl2 + 1][j] == 1) {\n            printf(\"D\");\n            ipl2++;\n        }\n    }\n\n    return 0;\n}\n",
    "Week-6 Programing Assignment-03": " #include &lt;stdio.h&gt;\n\nvoid dfs(int grid[20][20], int n, int i, int j) {\n    // Base conditions: out of bounds or water cell\n    if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == 0)\n        return;\n\n    // Mark current cell as visited by setting it to 0\n    grid[i][j] = 0;\n\n    // Move in all 4 directions (up, down, left, right)\n    dfs(grid, n, i + 1, j);\n    dfs(grid, n, i - 1, j);\n    dfs(grid, n, i, j + 1);\n    dfs(grid, n, i, j - 1);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int grid[20][20];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\", &grid[i][j]);\n\n    int count = 0;\n\n    // Traverse the matrix and find islands\n    for (int idi = 0; idi < n; idi++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[idi][j] == 1) {\n                count++;\n                dfs(grid, n, idi, j); // mark the entire island as visited\n            }\n        }\n    }\n\n    printf(\"%d\", count);\n    return 0;\n}\n"
  }
]

